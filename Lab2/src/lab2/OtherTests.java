package lab2;

import static org.junit.Assert.*;

import java.util.*;

import org.junit.Test;
import org.junit.rules.Timeout;
import org.junit.runners.MethodSorters;
import org.junit.FixMethodOrder;
import org.junit.Rule;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)

public class OtherTests {
	@Rule
	public Timeout globalTimeout = Timeout.seconds(1);
	
	// DIGITSCOUNTINSTRING METHOD
	
	@Test
	public void test_01_null_() {
		final String str = "";
		int n = Lab2Utilities.digitCountinString(str);
		int expect = 0;
		String failed = String.format("\nreturned = %d, expected = %d", n, expect);
		assertTrue(failed, expect == n);
	}
	
	@Test
	public void test_01_no_digits_() {
		final String str = "abcdefghijklmnopqrstuvwxyz";
		int n = Lab2Utilities.digitCountinString(str);
		int expect = 0;
		String failed = String.format("\nreturned = %d, expected = %d", n, expect);
		assertTrue(failed, expect == n);
	}
	
	@Test
	public void test_01_begin_() {
		final String str = "1bcdefghijk";
		int n = Lab2Utilities.digitCountinString(str);
		int expect = 1;
		String failed = String.format("\nreturned = %d, expected = %d", n, expect);
		assertTrue(failed, expect == n);
	}
	
	@Test
	public void test_01_end_() {
		final String str = "abcdefghijk1";
		int n = Lab2Utilities.digitCountinString(str);
		int expect = 1;
		String failed = String.format("\nreturned = %d, expected = %d", n, expect);
		assertTrue(failed, expect == n);
	}
	
	@Test
	public void test_01_begin_end_() {
		final String str = "1bcdefghij2";
		int n = Lab2Utilities.digitCountinString(str);
		int expect = 2;
		String failed = String.format("\nreturned = %d, expected = %d", n, expect);
		assertTrue(failed, expect == n);
	}
	
	@Test
	public void test_01_random_() {
		final String str = "iurnv798hb1d8980cnrmw09h23ub";
		int n = Lab2Utilities.digitCountinString(str);
		int expect = 12;
		String failed = String.format("\nreturned = %d, expected = %d", n, expect);
		assertTrue(failed, expect == n);
	}
	
	@Test
	public void test_01_all_digits_() {
		final String str = "0128937654";
		int n = Lab2Utilities.digitCountinString(str);
		int expect = 10;
		String failed = String.format("\nreturned = %d, expected = %d", n, expect);
		assertTrue(failed, expect == n);
	}
	
	// STRINGOFRANDOMINT METHOD
	
	@Test
	public void test_02_invalid_n_() {
		final int n = 0;
		final int x = 1;
		final int y = 2;
		
		String result = Lab2Utilities.stringOfRandomInt(n, x, y);
		String expect = "Argument passed to parameter n must be a positive value.";
		String failed = String.format("\nreturned = %s, expected = %s", result, expect);
		assertTrue(failed, result == expect);
	}
	
	@Test
	public void test_02_invalid_x_() {
		final int n = 1;
		final int x = 3;
		final int y = 2;
		
		String result = Lab2Utilities.stringOfRandomInt(n, x, y);
		String expect = "Argument passed to x parameter must be less than or equal to argument"
				+ " passed to y parameter";
		String failed = String.format("\nreturned = %s, expected = %s", result, expect);
		assertTrue(failed, result == expect);
	}
	
	@Test
	public void test_02_single_single_() {
		int n = 5;
		int x = 2;
		int y = 8;
		
		String result = Lab2Utilities.stringOfRandomInt(n, x, y);
		
		// factor of 3 since numbers are single digit and '<' and '>' for each number
		int expected_length = n * 3;
		int actual_length = result.length();
		String failed_length = String.format("\nreturned length = %d, expected length = %d", actual_length, expected_length);
		//assertEquals(failed_length, actual_length, expected_length);
	
		// above is testing for length of string generated by method, below testing content of string (simplified from given tests)
		
		// potentially need substring, depending on length of number to check, CHECK FROM < to >, trying to compare using ASCII values
		
		for (int i = 0; i < result.length(); ++i) {
			char character = result.charAt(i);
				if (Character.isDigit(character)) {
					// works for single character, but not for multiple characters (see note above)
						char x_str = Integer.toString(x).charAt(0); // for some reason, converting to char using (char) was insufficient
						char y_str = Integer.toString(y).charAt(0);
						System.out.println(String.format("char = %s, x = %s", character, x_str));//, character < x_str);
						System.out.println(String.format("char = %s, y = %s", character, y_str));//, character < y_str);
						if (character < x_str) {
							String failed_digit = String.format("\nreturned digit smaller than lower bound: %s < %s", character, x_str);
							assertTrue(failed_digit, character >= x_str);
						} else if (character > y_str) {
							String failed_digit = String.format("\nreturned digit larger than upper bound: %s > %s", character, y_str);
							assertTrue(failed_digit, character <= y_str);
						}
				}
		}
			
	}
	
	
	// LENGTHOFMAXCONSECUTIVEZEROS
	
	@Test
	public void test_03_null_() {
		final String n = "";
		int result = Lab2Utilities.lengthofMaxConsecutiveZeros(n);
		int expect = 0;
		String failed = String.format("\nreturned = %d, expected = %d", result, expect);
		assertTrue(failed, result == expect);
	}
	
}
